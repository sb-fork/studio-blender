"""Blender addon that exports drone show trajectories and light animation to
a simple (zipped) .csv format compatible with the Skybrush suite.

The primary and recommended drone show format of the Skybrush suite is the
Skybrush Compiled Format (.skyc), which is much more versatile and optimized
than the simple text output generated by this script.

This script is created for those who want to use their own scripts or tools for
post-processing.

To convert this (zipped) .csv to .skyc, login at our site and use
the online converter:

    https://account.skybrush.io

To install this addon:

    1. Open Blender
    2. Navigate to Edit -> Preferences
    3. Select the Add-ons tab
    4. Press 'Install...'
    5. Select this file and press 'Install Add-on'
"""

bl_info = {
    "name": "Export Skybrush-compatible CSV Format (.zip)",
    "author": "CollMot Robotics Ltd.",
    "description": "Export object trajectories and color animation to a Skybrush-compatible simple CSV format",
    "version": (1, 0, 1),
    "blender": (2, 83, 0),
    "location": "File > Export > Skybrush-CSV",
    "category": "Import-Export",
}

__license__ = "GPLv3"

#############################################################################
# imports needed by the addon

import bpy
import logging
import os
import re

from bpy.props import BoolProperty, StringProperty, EnumProperty, FloatProperty
from bpy.types import Operator
from bpy_extras.io_utils import ExportHelper
from dataclasses import dataclass
from fnmatch import fnmatch
from pathlib import Path
from typing import Dict, List
from zipfile import ZipFile, ZIP_DEFLATED

#############################################################################
# some global variables that could be parametrized if needed

SUPPORTED_TYPES = ("MESH",)  # ,'CURVE','EMPTY','TEXT','CAMERA','LAMP')


#############################################################################
# configure logger

log = logging.getLogger(__name__)
logging.basicConfig(
    format="%(asctime)s.%(msecs)03d %(message)s",
    level=logging.INFO,
    datefmt="%H:%M:%S",
)


#############################################################################
# Helper functions and classes for the exporter
#############################################################################


@dataclass
class TimePosColor:
    # time in milliseconds
    t: int
    # x position in meters
    x: float
    # y position in meters
    y: float
    # z position in meters
    z: float
    # red channel value [0-255]
    R: int
    # green channel value [0-255]
    G: int
    # blue channel value [0-255]
    B: int

    def __repr__(self):
        return f"{self.t},{round(self.x, ndigits=3)},{round(self.y, ndigits=3)},{round(self.z, ndigits=3)},{self.R},{self.G},{self.B}"


def _to_int_255(value: float) -> int:
    """Convert [0,1] float to clamped [0,255] int."""
    return int(max(0, min(255, round(value * 255))))


def _get_objects(context, settings):
    """Return generator for objects to export.

    Parameters:
        context: the main Blender context
        settings: export settings

    Yields:
        objects passing all specified filters natural-sorted by their name

    """
    # If Skybrush Studio for Blender is loaded, use the dedicated drone
    # collection, otherwise use all the objects from the scene
    skybrush = getattr(context.scene, "skybrush", None)
    drone_collection = skybrush.settings.drone_collection if skybrush else context.scene
    if drone_collection is None:
        return

    for obj in drone_collection.objects:
        if (
            obj.visible_get()
            and obj.type in SUPPORTED_TYPES
            and (
                not settings["export_name_filter"]
                or fnmatch(obj.name, settings["export_name_filter"])
            )
            and (obj.select_get() if settings["export_selected"] else 1)
        ):
            yield obj


def _get_location(obj):
    """Return global location of an object at the actual frame.

    Parameters:
        obj: a Blender object

    Return:
        location of object in the world frame

    """
    return tuple(obj.matrix_world.translation)


def _find_shader_node_by_name_and_type(material, name: str, type: str):
    """Finds the first shader node with the given name and expected type in the
    shader node tree of the given material.

    Lookup by name will likely fail if Blender is localized; in this case we
    will return the _first_ shader node that matches the given type.

    Parameters:
        name: the name of the shader node
        type: the expected type of the shader node

    Raises:
        KeyError: if there is no such shader node in the material
    """
    nodes = material.node_tree.nodes

    try:
        node = nodes[name]
        if node.type == type:
            return node
    except KeyError:
        pass

    # Lookup by name failed, let's try the slower way
    for node in nodes:
        if node.type == type:
            return node

    raise KeyError(f"no shader node with type {type!r} in material")


def _get_shader_node_and_input_for_diffuse_color_of_material(material):
    """Returns a reference to the shader node and its input that controls the
    diffuse color of the given material.

    The material must use a principled BSDF or an emission shader.

    Parameters:
        material: the Blender material to update

    Raises:
        ValueError: if the material does not use shader nodes
    """
    try:
        node = _find_shader_node_by_name_and_type(material, "Emission", "EMISSION")
        input = node.inputs["Color"]
        return node, input
    except KeyError:
        try:
            node = _find_shader_node_by_name_and_type(
                material, "Principled BSDF", "BSDF_PRINCIPLED"
            )
            input = node.inputs["Base Color"]
            return node, input
        except KeyError:
            try:
                node = _find_shader_node_by_name_and_type(
                    material, "Principled BSDF", "BSDF_PRINCIPLED"
                )
                input = node.inputs["Emission"]
                return node, input
            except KeyError:
                raise ValueError("Material does not have a diffuse color shader node")


def _get_color(obj, frame):
    """Return diffuse_color of an object at the actual frame.

    Parameters:
        obj: a Blender object
        frame: the current frame

    Return:
        color of object as an R, G, B tuple in [0-255]

    """
    # if there is no material or diffuse color, we return black
    material = obj.active_material
    if not material or not material.diffuse_color:
        return (0, 0, 0)

    # if color is not animated with nodes, use a single color (that can be
    # an animated color as well, which is already evaluated at the given frame)
    if not material.use_nodes:
        return (
            _to_int_255(material.diffuse_color[0]),
            _to_int_255(material.diffuse_color[1]),
            _to_int_255(material.diffuse_color[2]),
        )

    # if a shader node is used, sample it on the given frame
    node, input = _get_shader_node_and_input_for_diffuse_color_of_material(material)
    animation = material.node_tree.animation_data
    # if it is not animated, get the default value
    if not animation:
        rgb = input.default_value[:3]
    # if it is animated, evaluate shader node on the given frame
    else:
        index = node.inputs.find(input.name)
        data_path = f'nodes["{node.name}"].inputs[{index}].default_value'
        rgb = [0, 0, 0]
        for fc in animation.action.fcurves:
            if fc.data_path != data_path:
                continue

            # iterate channels (r, g, b) only
            if fc.array_index not in (0, 1, 2):
                continue

            rgb[fc.array_index] = fc.evaluate(frame)

    return (
        _to_int_255(rgb[0]),
        _to_int_255(rgb[1]),
        _to_int_255(rgb[2]),
    )


def _get_frame_range_from_export_settings(context, settings):
    """Get framerange and related variables.

    Parameters:
        context: the main Blender context
        settings: export settings

    Return:
        framerange to be used during the export. Framerange is a 3-tuple
        consisting of (first_frame, last_frame, frame_skip_factor)

    """
    # define frame range and other variables
    fps = context.scene.render.fps
    fpsskip = int(fps / settings["output_fps"])
    if settings["frame_range"] == "RENDER":
        frame_range = [context.scene.frame_start, context.scene.frame_end, fpsskip]
    elif settings["frame_range"] == "PREVIEW":
        frame_range = [
            context.scene.frame_preview_start,
            context.scene.frame_preview_end,
            fpsskip,
        ]
    else:
        raise NotImplementedError("Unknown frame range source")

    return frame_range


def _get_trajectories_and_lights(
    context, settings, frame_range: tuple
) -> Dict[str, List[TimePosColor]]:
    """Get trajectories and lights of all selected/picked objects.

    Parameters:
        context: the main Blender context
        settings: export settings
        framerange: the framerange used for exporting

    Return:
        drone show data in lists of TimePosColor entries, in a dictionary, indexed by object names

    """

    # get object trajectories for each needed frame in convenient format
    fps = context.scene.render.fps
    data = {}
    context.scene.frame_set(frame_range[0])
    objects = list(_get_objects(context, settings))
    # initialize trajectories and lights
    for obj in objects:
        data[obj.name] = []
    # parse trajectories and lights
    for frame in range(frame_range[0], frame_range[1] + frame_range[2], frame_range[2]):
        log.debug(f"processing frame {frame}")
        context.scene.frame_set(frame)
        for obj in objects:
            pos = _get_location(obj)
            color = _get_color(obj, frame)
            data[obj.name].append(TimePosColor(int(frame / fps * 1000), *pos, *color))

    return data


def _export_data_to_zip(data_dict: Dict[str, List[TimePosColor]], filepath: Path):
    """Export data to individual csv files zipped into a common file."""
    # write .csv files in a .zip file
    with ZipFile(filepath, "w", ZIP_DEFLATED) as zip_file:
        for name, data in data_dict.items():
            safe_name = re.sub(r"[^A-Za-z0-9\.\+\-]", "_", name)
            lines = [
                ",".join(
                    ["Time [msec]", "x [m]", "y [m]", "z [m]", "Red", "Green", "Blue"]
                )
            ] + [str(item) for item in data]
            zip_file.writestr(safe_name + ".csv", "\n".join(lines))


def _write_skybrush_file(context, settings, filepath: Path) -> dict:
    """Creates Skybrush-compatible CSV output from blender trajectories and
    color animation.

    This is a helper function for SkybrushCSVExportOperator

    Parameters:
        context: the main Blender context
        settings: export settings
        filepath: the output path where the export should write

    """

    # get framerange
    log.info("Getting frame range from {}".format(settings["frame_range"]))
    frame_range = _get_frame_range_from_export_settings(context, settings)
    # get trajectories and lights
    log.info("Getting object trajectories and lights")
    trajectories_and_lights = _get_trajectories_and_lights(
        context, settings, frame_range
    )
    # export data to a .zip file containing .csv files
    log.info(f"Exporting object trajectories and light animation to {filepath}")
    _export_data_to_zip(trajectories_and_lights, filepath)

    log.info("Export finished")


def _make_annotations(cls):
    """Converts class fields to annotations.

    This is needed because apparently the syntax that Blender 2.80 uses for
    the class properties (i.e. using IntProperty(), FloatProperty() etc) confuses
    Python static type checkers like Pyright or Pylance. We stick to the older
    Blender 2.7x-style annotations and then convert them on-the fly when the
    class is registered as an operator.
    """
    # Before Blender 2.93, properties in Blender classes were instances of
    # tuples so we look for that. Blender 2.93 changed this to
    # bpy.props._PropertyDeferred
    try:
        from bpy.props import _PropertyDeferred
    except ImportError:
        _PropertyDeferred = tuple

    bl_props = {
        k: v for k, v in cls.__dict__.items() if isinstance(v, _PropertyDeferred)
    }

    if bl_props:
        if "__annotations__" not in cls.__dict__:
            setattr(cls, "__annotations__", {})
        annotations = cls.__dict__["__annotations__"]
        for k, v in bl_props.items():
            annotations[k] = v
            delattr(cls, k)

    return cls


#############################################################################
# Operator that allows the user to invoke the export operation
#############################################################################


class SkybrushCSVExportOperator(Operator, ExportHelper):
    """Export object trajectories and light animation into Skybrush-compatible simple CSV format."""

    bl_idname = "export_scene.skybrush_csv"
    bl_label = "Export Skybrush CSV"
    bl_options = {"REGISTER"}

    # List of file extensions that correspond to Skybrush CSV files (zipped)
    filter_glob = StringProperty(default="*.zip", options={"HIDDEN"})
    filename_ext = ".zip"

    # export objects with the given name filter
    export_name_filter = StringProperty(
        name="Object name filter",
        default="",
        description="Define a name filter on the selected objects to be exported. Use the `*` wildcard for convenience.",
    )

    # output all objects or only selected ones
    export_selected = BoolProperty(
        name="Export selected objects only",
        default=False,
        description=(
            "Export only the selected objects from the scene. Uncheck to export "
            "all objects, irrespectively of the selection."
        ),
    )

    # frame range
    frame_range = EnumProperty(
        name="Frame range",
        description="Choose a frame range to use for export",
        items=(
            ("RENDER", "Render", "Use global render frame range set by scene"),
            ("PREVIEW", "Preview", "Use global preview frame range set by scene"),
        ),
        default="RENDER",
    )

    # output frame rate
    output_fps = FloatProperty(
        name="Frame rate",
        default=4,
        description="Temporal resolution of exported trajectory and light (frames per second)",
    )

    def execute(self, context):
        filepath = bpy.path.ensure_ext(self.filepath, self.filename_ext)
        settings = {
            "export_name_filter": self.export_name_filter,
            "export_selected": self.export_selected,
            "frame_range": self.frame_range,
            "output_fps": self.output_fps,
        }

        if os.path.basename(filepath).lower() == self.filename_ext.lower():
            self.report({"ERROR_INVALID_INPUT"}, "Filename must not be empty")
            return {"CANCELLED"}

        objects = list(_get_objects(context, settings))
        if not objects:
            if self.export_selected:
                self.report({"WARNING"}, "No objects were selected; export cancelled")
            else:
                self.report(
                    {"WARNING"}, "There are no objects to export; export cancelled"
                )
            return {"CANCELLED"}

        _write_skybrush_file(context, settings, filepath)

        return {"FINISHED"}

    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return {"RUNNING_MODAL"}


#############################################################################
# Boilerplate to register this as an item in the File / Export menu
#############################################################################


def menu_func_export(self, context):
    self.layout.operator(
        SkybrushCSVExportOperator.bl_idname, text="Skybrush CSV (.zip)"
    )


def register():
    _make_annotations(SkybrushCSVExportOperator)
    bpy.utils.register_class(SkybrushCSVExportOperator)
    bpy.types.TOPBAR_MT_file_export.append(menu_func_export)


def unregister():
    bpy.utils.unregister_class(SkybrushCSVExportOperator)
    bpy.types.TOPBAR_MT_file_export.remove(menu_func_export)


if __name__ == "__main__":
    register()

    # test call
    bpy.ops.object.SkybrushCSVExportOperator("INVOKE_DEFAULT")
